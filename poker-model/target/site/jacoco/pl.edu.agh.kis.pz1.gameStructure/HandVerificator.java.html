<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="no"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HandVerificator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">poker-model</a> &gt; <a href="index.source.html" class="el_package">pl.edu.agh.kis.pz1.gameStructure</a> &gt; <span class="el_source">HandVerificator.java</span></div><h1>HandVerificator.java</h1><pre class="source lang-java linenums">package pl.edu.agh.kis.pz1.gameStructure;
import pl.edu.agh.kis.pz1.*;

import java.util.*;
/**
 * Klasa reprezentująca sprawdzanie rąk
 */
public class HandVerificator {
    /**
     * Lista talii graczy
     */
    private final List&lt;Deck&gt; players;
    /**
     * Lista rąk jakie gracze uzyskali i ich score
     */
<span class="fc" id="L16">    private final List&lt;Tuple&gt; playerHands = new ArrayList&lt;&gt;();</span>
    /**
     * Konstruktor klasy HandVerificator
     * @param _players to parametr reprezentujący listę talii graczy
     */
<span class="fc" id="L21">    public HandVerificator(List&lt;Deck&gt; _players) {</span>
<span class="fc" id="L22">        players = _players;</span>
<span class="fc" id="L23">        verifyIfEnoughCards();</span>
<span class="fc" id="L24">    }</span>
    /**
     * Metoda sprawdzająca czy każdy gracz ma wystarczającą ilość kart
     */
    void verifyIfEnoughCards() {
<span class="fc bfc" id="L29" title="All 2 branches covered.">        for (Deck playerDeck : players) {</span>
<span class="fc bfc" id="L30" title="All 2 branches covered.">            if (playerDeck.getSize() != 5) {</span>
<span class="fc" id="L31">                throw new IllegalArgumentException(&quot;Not enough cards in player deck&quot;);</span>
            }
<span class="fc" id="L33">        }</span>
<span class="fc" id="L34">    }</span>

    /**
     * Metoda przypisująca graczom zweryfikowane ręce i ich score
     * @return zwraca listę rąk graczy i ich score
     */
    public List&lt;Tuple&gt; verifyHands() {
<span class="fc bfc" id="L41" title="All 2 branches covered.">        for (Deck playerDeck : players) {</span>
<span class="fc" id="L42">            playerHands.add(analyzeDeck(playerDeck));</span>
<span class="fc" id="L43">        }</span>
<span class="fc" id="L44">        return playerHands;</span>
    }

    /**
     * Metoda analizująca talię gracza i zwracająca jego rękę i score, który jest wynikiem sumy wartości kart
     * @param pd to parametr reprezentujący talię gracza
     * @return zwraca rękę gracza i jej score
     */
    Tuple analyzeDeck(Deck pd) {
        // sortowanie kart w talii gracza
<span class="fc" id="L54">        pd.sort();</span>
        // sprawdzenie czy gracz ma kolor
<span class="fc" id="L56">        boolean flush = checkForSameSuit(pd);</span>
        // sprawdzenie czy gracz ma strit
<span class="fc" id="L58">        boolean straight = checkForStraight(pd);</span>

<span class="fc bfc" id="L60" title="All 4 branches covered.">        if (flush &amp;&amp; straight) { // sprawdzenie czy gracz ma pokera</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">            if (pd.getCard(4).getRank() == cardRank.ACE) {</span>
<span class="fc" id="L62">                return new Tuple(pokerHand.ROYALFLUSH, 0);</span>
            } else {
<span class="fc" id="L64">                return new Tuple(pokerHand.STRAIGHTFLUSH, pd.getCard(4).getRank().getOrder()+1);</span>
            }
<span class="fc bfc" id="L66" title="All 2 branches covered.">        } else if (flush) {</span>
<span class="fc" id="L67">            int score = (pd.getCard(0).getRank().getOrder()+1) + ((pd.getCard(1).getRank().getOrder()+1) * 100)</span>
<span class="fc" id="L68">                    + ((pd.getCard(2).getRank().getOrder()+1) * 10000) + ((pd.getCard(3).getRank().getOrder()+1) * 1000000)</span>
<span class="fc" id="L69">                    + ((pd.getCard(4).getRank().getOrder()+1) * 100000000);</span>
<span class="fc" id="L70">            return new Tuple(pokerHand.FLUSH, score);</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        } else if (straight) {</span>
<span class="fc" id="L72">            return new Tuple(pokerHand.STRAIGHT, pd.getCard(4).getRank().getOrder()+1);</span>
            // po wykluczeniu pokera, koloru i strita sprawdzamy czy gracz ma trójkę, dwie pary, jedną parę lub nic
        } else {
<span class="nc" id="L75">            return checkSameCardsHands(pd);</span>
        }
    }

    /**
     * Metoda sprawdzająca czy talia kart zawiera tylko karty tego samego koloru
     * @param pd to parametr reprezentujący talię gracza
     * @return zwraca true jeśli gracz ma kolor, false jeśli nie ma
     */
    boolean checkForSameSuit(Deck pd) {
<span class="fc" id="L85">        Card first = pd.getCard(0);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        for (int i = 1; i &lt; 5; i++) {</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            if (first.getSuit() != pd.getCard(i).getSuit()) {</span>
<span class="fc" id="L88">                return false;</span>
            }
        }
<span class="fc" id="L91">        return true;</span>
    }

    /**
     * Metoda sprawdzająca czy talia kart zawiera strita przy założeniu że talia kart jest posortowana
     * @param pd to parametr reprezentujący talię gracza
     * @return zwraca true jeśli gracz ma strita, false jeśli nie ma
     */
    boolean checkForStraight(Deck pd) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            if (pd.getCard(i).getRank().getOrder() != (pd.getCard(i + 1).getRank().getOrder() - 1)) {</span>
<span class="fc" id="L102">                return false;</span>
            }
        }
<span class="fc" id="L105">        return true;</span>
    }

    /**
     * Metoda sprawdzająca czy gracz ma trójkę, dwie pary, jedną parę bądź nic
     * @param pd to parametr reprezentujący talię gracza
     * @return zwraca rękę gracza i ostateczny wynik
     */
    Tuple checkSameCardsHands(Deck pd) {
        // zliczanie ilości kart o tej samej wartości
<span class="fc" id="L115">        Map&lt;Integer, Integer&gt; deck = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        for (int i = 0; i &lt; 5; i++) {</span>
<span class="fc" id="L117">            deck.merge(pd.getCard(i).getRank().getOrder(), 1, Integer::sum);</span>
        }
        // sprawdzanie czy gracz ma trójkę, dwie pary, jedną parę bądź nic
<span class="fc" id="L120">        int four = 0;</span>
<span class="fc" id="L121">        int three = 0;</span>
<span class="fc" id="L122">        List&lt;Integer&gt; pairs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L123">        List&lt;Integer&gt; singles = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        for (var i : deck.entrySet()) {</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (deck.get(i.getKey()) == 2) {</span>
<span class="fc" id="L126">                pairs.add(i.getKey() + 1);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            } else if (deck.get(i.getKey()) == 3) {</span>
<span class="fc" id="L128">                three = i.getKey() + 1;</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            } else if (deck.get(i.getKey()) == 4) {</span>
<span class="fc" id="L130">                four = i.getKey() + 1;</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            } else if (deck.get(i.getKey()) == 1) {</span>
<span class="fc" id="L132">                singles.add(i.getKey() + 1);</span>
            }
<span class="fc" id="L134">        }</span>
        // oblicznaie wyników do poszczególnych rąk w celu rozstrzygnięcia remisów
<span class="fc" id="L136">        return getTupleOfResults(four, three, pairs, singles);</span>
    }

    /**
     * Metoda obliczająca wynik dla poszczególnych rąk gracza
     * @param four - parametr reprezentujący ilość czwórek
     * @param three - parametr reprezentujący ilość trójek
     * @param pairs - parametr reprezentujący ilość par
     * @param singles - parametr reprezentujący ilość kart o innej wartości niż pozostałe
     * @return zwraca rękę gracza i ostateczny wynik
     */
    private Tuple getTupleOfResults(int four, int three, List&lt;Integer&gt; pairs, List&lt;Integer&gt; singles) {
        int score;
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (four &gt; 0) {</span>
<span class="fc" id="L150">            score = (four * 100) + singles.get(0);</span>
<span class="fc" id="L151">            return new Tuple(pokerHand.FOUR, score);</span>
<span class="fc bfc" id="L152" title="All 4 branches covered.">        } else if (three &gt; 0 &amp;&amp; pairs.size() == 1) {</span>
<span class="fc" id="L153">            score = (three * 100) + pairs.get(0);</span>
<span class="fc" id="L154">            return new Tuple(pokerHand.FULLHOUSE, score);</span>
<span class="pc bpc" id="L155" title="1 of 4 branches missed.">        } else if (three &gt; 0 &amp;&amp; pairs.size() == 0) {</span>
<span class="fc" id="L156">            score = (three * 10000) + (singles.get(1) * 100) + (singles.get(0));</span>
<span class="fc" id="L157">            return new Tuple(pokerHand.THREE, score);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        } else if (pairs.size() == 2) {</span>
<span class="fc" id="L159">            score = (pairs.get(1) * 10000) + (pairs.get(0) * 100) + (singles.get(0));</span>
<span class="fc" id="L160">            return new Tuple(pokerHand.TWOPAIR, score);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        } else if (pairs.size() == 1) {</span>
<span class="fc" id="L162">            score = (pairs.get(0) * 1000000) + (singles.get(2) * 10000) + (singles.get(1) * 100) + (singles.get(0));</span>
<span class="fc" id="L163">            return new Tuple(pokerHand.ONEPAIR, score);</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        } else if (pairs.size() == 0) {</span>
<span class="fc" id="L165">            score = (singles.get(4) * 100000000) + (singles.get(3) * 1000000) + (singles.get(2) * 10000) + (singles.get(1) * 100) + (singles.get(0));</span>
<span class="fc" id="L166">            return new Tuple(pokerHand.HIGHCARD, score);</span>
        }
        else {
<span class="nc" id="L169">            return new Tuple(pokerHand.HIGHCARD, 0);</span>
        }
    }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>